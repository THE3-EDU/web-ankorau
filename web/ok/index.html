<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OK Hand Gesture with Image</title>
  <!-- 
    使用本地文件版本（推荐，避免 CDN 问题）
    下载文件后取消下面的注释，注释掉 CDN 版本
  -->
  <script src="libs/p5.js"></script>
  <script src="libs/ml5.min.js"></script>
  
  <!-- 
    CDN 版本（如果本地文件不存在，使用这个）
    如果使用本地文件，请注释掉下面两行
  -->
  <!--
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>
  -->
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
let handPose;
let video;
let hands = [];
let options = {flipped: true};

let pts = []; 
let okCreated = false;
let okImage;
let modelReady = false;
let videoReady = false;
let initAttempts = 0;
let maxInitAttempts = 2;

function preload() {
  // 替换为你自己的图片路径或 URL
  okImage = loadImage('test.jpeg'); 
  
  // 在 preload 中开始加载模型（不需要 video）
  console.log('开始预加载 HandPose 模型...');
  handPose = ml5.handPose({
    runtime: 'tfjs',        // 使用 tfjs runtime
    modelType: 'lite',     // 使用 lite 模型，加载更快
    maxHands: 1
  }, function() {
    modelReady = true;
    console.log('HandPose 模型预加载完成');
    // 如果 video 已经准备好，立即开始检测
    if (videoReady && video) {
      try {
        handPose.detectStart(video, gotHands);
        console.log('开始手势检测');
      } catch (error) {
        console.error('启动检测失败:', error);
      }
    }
  });
}

function setup() {
  createCanvas(640, 480);
  
  // 初始化摄像头
  video = createCapture(VIDEO);
  video.size(640, 480);
  video.hide();
  
  // 使用 video.elt 访问底层 DOM 元素来监听事件
  if (video.elt) {
    video.elt.addEventListener('loadedmetadata', function() {
      videoReady = true;
      console.log('摄像头已就绪');
      // 如果模型已经加载完成，立即开始检测
      if (modelReady && handPose) {
        try {
          handPose.detectStart(video, gotHands);
          console.log('开始手势检测');
        } catch (error) {
          console.error('启动检测失败:', error);
        }
      }
    });
    
    video.elt.addEventListener('error', function(err) {
      console.error('摄像头错误:', err);
      alert('无法访问摄像头。请检查权限设置或确保使用 HTTPS 协议。');
    });
  }
  
  // 如果 video.elt 还没准备好，延迟检查
  setTimeout(function() {
    if (!videoReady && video.elt && video.elt.readyState >= 2) {
      videoReady = true;
      console.log('摄像头已就绪（延迟检查）');
      // 如果模型已经加载完成，立即开始检测
      if (modelReady && handPose) {
        try {
          handPose.detectStart(video, gotHands);
          console.log('开始手势检测');
        } catch (error) {
          console.error('启动检测失败:', error);
        }
      }
    }
  }, 1000);
}

function initHandPose() {
  if (modelReady) return; // 如果已经加载成功，不再初始化
  if (initAttempts >= maxInitAttempts) {
    console.error('已达到最大重试次数，模型加载失败');
    return;
  }
  
  initAttempts++;
  console.log('开始初始化 HandPose 模型... (尝试 ' + initAttempts + '/' + maxInitAttempts + ')');
  
  // 根据尝试次数选择不同的 runtime
  let useRuntime = initAttempts === 1 ? 'tfjs' : 'mediapipe'; // 先尝试 tfjs，如果失败再用 mediapipe
  
  // 设置超时，如果 30 秒还没加载完成，尝试使用另一个 runtime
  let loadTimeout = setTimeout(function() {
    if (!modelReady && initAttempts < maxInitAttempts) {
      console.warn('模型加载超时，尝试使用另一个 runtime...');
      if (handPose) {
        try {
          handPose.detectStop();
        } catch(e) {}
        handPose = null;
      }
      initHandPose(); // 重试
    } else if (!modelReady) {
      console.error('模型加载最终失败');
      alert('手势识别模型加载失败。\n可能原因：\n1. 网络连接问题\n2. CDN 访问受限\n\n请检查网络连接或稍后重试。');
    }
  }, 30000);
  
  // 初始化 handPose 模型
  try {
    handPose = ml5.handPose({
      runtime: useRuntime,    // 先尝试 tfjs，它可能更容易加载
      modelType: 'lite',      // 使用 lite 模型，加载更快
      maxHands: 1,            // 减少最大手数
      flipHorizontal: true
    }, function() {
      clearTimeout(loadTimeout);
      modelReady = true;
      console.log('HandPose 模型已加载 (使用 ' + useRuntime + ' runtime)');
      // 开始检测
      if (videoReady && handPose) {
        try {
          handPose.detectStart(video, gotHands);
        } catch (error) {
          console.error('启动检测失败:', error);
          // 如果 detectStart 失败，尝试重新初始化
          if (initAttempts < maxInitAttempts) {
            setTimeout(function() {
              handPose = null;
              modelReady = false;
              initHandPose();
            }, 1000);
          }
        }
      }
    });
  } catch (error) {
    clearTimeout(loadTimeout);
    console.error('HandPose 初始化失败:', error);
    // 如果还有重试机会，延迟后重试
    if (initAttempts < maxInitAttempts) {
      setTimeout(function() {
        handPose = null;
        initHandPose();
      }, 2000);
    } else {
      alert('手势识别模型初始化失败。\n可能原因：\n1. 网络连接问题\n2. CDN 访问受限\n\n请检查网络连接或稍后重试。');
    }
  }
}

function draw() {
  // 检查视频是否就绪（如果还没标记为就绪）
  if (!videoReady && video && video.elt && video.elt.readyState >= 2) {
    videoReady = true;
    console.log('摄像头已就绪（draw 中检测）');
    // 如果模型已经加载完成，立即开始检测
    if (modelReady && handPose) {
      try {
        handPose.detectStart(video, gotHands);
        console.log('开始手势检测');
      } catch (error) {
        console.error('启动检测失败:', error);
      }
    }
  }
  
  // 显示加载状态
  if (!videoReady || !modelReady) {
    background(0);
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(20);
    let status = '';
    if (!videoReady) {
      status = '正在请求摄像头权限...';
    } else if (!modelReady) {
      status = '正在加载手势识别模型...\n首次加载可能需要较长时间\n请耐心等待';
      if (initAttempts > 1) {
        status += '\n(尝试 ' + initAttempts + '/' + maxInitAttempts + ')';
      }
      textSize(16);
    }
    text(status, width/2, height/2);
    
    // 显示加载动画
    if (!modelReady && videoReady) {
      let dots = '';
      let dotCount = floor(millis() / 500) % 4;
      for (let i = 0; i < dotCount; i++) {
        dots += '.';
      }
      fill(200);
      textSize(14);
      text('加载中' + dots, width/2, height/2 + 40);
    }
    return;
  }
  
  // 显示视频画面
  if (video && video.elt && video.elt.readyState >= 2) {
    image(video, 0, 0, width, height);
  } else {
    background(0);
    fill(255);
    textAlign(CENTER, CENTER);
    text('等待摄像头...', width/2, height/2);
    return;
  }
  
  trackHandPosition();

  // 检测 OK 手势
  let okDetected = false;
  let currentHand = null;
  for (let i = 0; i < hands.length; i++) {
    if (checkOK(hands[i])) {
      okDetected = true;
      currentHand = hands[i]; // 保存整个手部数据
      break;
    }
  }

  // 设置 okCreated
  if (okDetected && !okCreated) {
    okCreated = true;
    console.log("OK 手势被创建了！");
  } else if (!okDetected && okCreated) {
    okCreated = false;
    console.log("OK 手势已重置");
  }

  // 如果 OK 手势存在，画图片在拇指和食指形成的轮廓中
  if (okDetected && currentHand) {
    let keypoints = currentHand.keypoints;
    
    // 先绘制所有关键点（用于调试）
    push();
    for (let i = 0; i < keypoints.length; i++) {
      let kp = keypoints[i];
      if (kp) {
        // 根据关键点类型设置不同颜色
        if (i === 0) {
          fill(255, 0, 0); // 手腕 - 红色
        } else if (i >= 1 && i <= 4) {
          fill(0, 255, 0); // 拇指 - 绿色
        } else if (i >= 5 && i <= 8) {
          fill(0, 0, 255); // 食指 - 蓝色
        } else if (i >= 9 && i <= 12) {
          fill(255, 255, 0); // 中指 - 黄色
        } else if (i >= 13 && i <= 16) {
          fill(255, 0, 255); // 无名指 - 紫色
        } else {
          fill(0, 255, 255); // 小指 - 青色
        }
        
        noStroke();
        ellipse(kp.x, kp.y, 8, 8);
        
        // 标注关键点编号
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(10);
        text(i, kp.x, kp.y);
      }
    }
    pop();
    
    // 获取拇指和食指的关键点
    // 拇指：1(根部), 2, 3, 4(指尖)
    // 食指：5(根部), 6, 7, 8(指尖)
    let thumb1 = keypoints[1]; // 拇指根部
    let thumb2 = keypoints[2];
    let thumb3 = keypoints[3];
    let thumb4 = keypoints[4]; // 拇指尖
    
    let index5 = keypoints[5]; // 食指根部
    let index6 = keypoints[6];
    let index7 = keypoints[7];
    let index8 = keypoints[8]; // 食指尖
    
    // 计算点2和点5之间的中间连接点（朝向"O"的中心偏移，让轮廓更圆润）
    let mid25X = (thumb2.x + index5.x) / 2;
    let mid25Y = (thumb2.y + index5.y) / 2;
    
    // 计算"O"的中心点（拇指尖和食指尖的中点）
    let centerX = (thumb4.x + index8.x) / 2;
    let centerY = (thumb4.y + index8.y) / 2;
    
    // 计算从中间点指向"O"中心的方向（然后反向，让中间点向外偏移）
    let toCenterX = centerX - mid25X;
    let toCenterY = centerY - mid25Y;
    let toCenterLen = sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
    
    // 归一化方向向量，然后反向（向外偏移）
    if (toCenterLen > 0) {
      toCenterX = -toCenterX / toCenterLen; // 反向，向外
      toCenterY = -toCenterY / toCenterLen; // 反向，向外
    }
    
    // 计算点2和点5之间的距离
    let dx = index5.x - thumb2.x;
    let dy = index5.y - thumb2.y;
    let len = sqrt(dx * dx + dy * dy);
    
    // 向外偏移一定距离，让轮廓更圆润
    let offset = len * 0.3; // 偏移距离为两点距离的30%
    let midPointX = mid25X + toCenterX * offset;
    let midPointY = mid25Y + toCenterY * offset;
    
    // 绘制轮廓路径的预览线（用于调试）
    push();
    noFill();
    stroke(255, 255, 0); // 黄色轮廓线
    strokeWeight(2);
    beginShape();
    vertex(thumb2.x, thumb2.y); // 从点2开始
    vertex(thumb3.x, thumb3.y);
    vertex(thumb4.x, thumb4.y);
    vertex(index8.x, index8.y);
    vertex(index7.x, index7.y);
    vertex(index6.x, index6.y);
    vertex(index5.x, index5.y);
    vertex(midPointX, midPointY); // 中间连接点
    endShape(CLOSE); // 自动连接到起点（点2）
    pop();
    
    // 绘制中间连接点（用于调试）
    push();
    fill(255, 165, 0); // 橙色标记中间点
    noStroke();
    ellipse(midPointX, midPointY, 8, 8);
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(10);
    text('M', midPointX, midPointY); // M 表示中间点
    pop();
    
    // 创建轮廓路径：从点2开始，沿着拇指到指尖，然后沿着食指回到点5，最后点5和点2直接连接
    push();
    drawingContext.save();
    
    // 开始创建路径
    drawingContext.beginPath();
    
    // 从点2开始（拇指的第二个关键点）
    drawingContext.moveTo(thumb2.x, thumb2.y);
    
    // 从 thumb2 到 thumb3
    let cp2x = thumb2.x + (thumb3.x - thumb2.x) * 0.5;
    let cp2y = thumb2.y + (thumb3.y - thumb2.y) * 0.5;
    drawingContext.quadraticCurveTo(cp2x, cp2y, thumb3.x, thumb3.y);
    
    // 从 thumb3 到 thumb4（指尖）
    let cp3x = thumb3.x + (thumb4.x - thumb3.x) * 0.5;
    let cp3y = thumb3.y + (thumb4.y - thumb3.y) * 0.5;
    drawingContext.quadraticCurveTo(cp3x, cp3y, thumb4.x, thumb4.y);
    
    // 从拇指尖到食指尖（连接两个指尖，使用平滑曲线）
    let midX = (thumb4.x + index8.x) / 2;
    let midY = (thumb4.y + index8.y) / 2;
    drawingContext.quadraticCurveTo(midX, midY, index8.x, index8.y);
    
    // 沿着食指内侧回到食指根部（使用贝塞尔曲线）
    // 从 index8 到 index7
    let cp4x = index8.x + (index7.x - index8.x) * 0.5;
    let cp4y = index8.y + (index7.y - index8.y) * 0.5;
    drawingContext.quadraticCurveTo(cp4x, cp4y, index7.x, index7.y);
    
    // 从 index7 到 index6
    let cp5x = index7.x + (index6.x - index7.x) * 0.5;
    let cp5y = index7.y + (index6.y - index7.y) * 0.5;
    drawingContext.quadraticCurveTo(cp5x, cp5y, index6.x, index6.y);
    
    // 从 index6 到 index5（根部）
    let cp6x = index6.x + (index5.x - index6.x) * 0.5;
    let cp6y = index6.y + (index5.y - index6.y) * 0.5;
    drawingContext.quadraticCurveTo(cp6x, cp6y, index5.x, index5.y);
    
    // 从点5用直线连接到M点，然后从M点用直线连接到点2
    drawingContext.lineTo(midPointX, midPointY); // 从点5到M点
    drawingContext.lineTo(thumb2.x, thumb2.y);    // 从M点到点2
    drawingContext.closePath();
    
    // 使用这个路径作为裁剪区域
    drawingContext.clip();
    
    // 计算图片的边界框（稍微扩大一点，确保完全覆盖）
    let padding = 10; // 边缘填充
    let minX = min(thumb2.x, thumb3.x, thumb4.x, index5.x, index6.x, index7.x, index8.x) - padding;
    let maxX = max(thumb2.x, thumb3.x, thumb4.x, index5.x, index6.x, index7.x, index8.x) + padding;
    let minY = min(thumb2.y, thumb3.y, thumb4.y, index5.y, index6.y, index7.y, index8.y) - padding;
    let maxY = max(thumb2.y, thumb3.y, thumb4.y, index5.y, index6.y, index7.y, index8.y) + padding;
    
    let imgWidth = maxX - minX;
    let imgHeight = maxY - minY;
    
    // 绘制图片（会被轮廓路径裁剪，边缘会自然融合）
    image(okImage, minX, minY, imgWidth, imgHeight);
    
    // 恢复裁剪区域
    drawingContext.restore();
    pop();
  }
}

function trackHandPosition() {
  let updatedPts = [];
  for (let i = 0; i < hands.length; i++) {
    let hand = hands[i]; 
    let handedness = hand.handedness;
    let keypoints = hand.keypoints;
    
    if (handedness == "Left") {
      updatedPts[0] = keypoints[4];
      updatedPts[1] = keypoints[3];
      updatedPts[2] = keypoints[2];
      updatedPts[3] = keypoints[5];
      updatedPts[4] = keypoints[6];
      updatedPts[5] = keypoints[7];
      updatedPts[6] = keypoints[8];
    }
    
    if (handedness == "Right") {
      updatedPts[7] = keypoints[8];
      updatedPts[8] = keypoints[7];
      updatedPts[9] = keypoints[6];
      updatedPts[10] = keypoints[5];
      updatedPts[11] = keypoints[2];
      updatedPts[12] = keypoints[3];
      updatedPts[13] = keypoints[4];
    }  
  }
  pts = updatedPts;
}

function gotHands(results) {
  hands = results;
}

// --------- 检查单手 OK 手势 ---------
function checkOK(hand) {
  let keypoints = hand.keypoints;
  if (!keypoints) return false;

  let thumb = keypoints[4];
  let index = keypoints[8];
  let middleTip = keypoints[12];
  let ringTip = keypoints[16];
  let pinkyTip = keypoints[20];
  let wrist = keypoints[0];

  if (!thumb || !index || !middleTip || !ringTip || !pinkyTip || !wrist) return false;

  let thumbIndexDist = dist(thumb.x, thumb.y, index.x, index.y);
  let minStraightDist = 50;

  let middleStraight = dist(middleTip.x, middleTip.y, wrist.x, wrist.y) > minStraightDist;
  let ringStraight = dist(ringTip.x, ringTip.y, wrist.x, wrist.y) > minStraightDist;
  let pinkyStraight = dist(pinkyTip.x, pinkyTip.y, wrist.x, wrist.y) > minStraightDist;

  return thumbIndexDist < 30 && middleStraight && ringStraight && pinkyStraight;
}
</script>
</body>
</html>